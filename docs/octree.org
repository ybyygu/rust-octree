#+TITLE: Octree for neareset neighbors search
#+SETUPFILE: ~/Notes/common.org
#+SETUPFILE: ~/Notes/coding.org

* docs
:PROPERTIES:
:EXPORT_FILE_NAME: octree.odt
:END:
专门针对三维数据点的特征发展的高效搜索算法.
** 问题定义
P是三维数据点集合:

\[
P=\left\{ p_{1},\cdots,p_{N}\right\} ,p_{i}\in\mathbb{R}^{3}
\]

求一定距离范围内的邻近数据点:

\[
N\left(q,r\right)=\left\{ p\in P\mid\left|\left|p-q\right|\right|<r\right\} ,
\]

** 算法原理
octree是基于空间切分算法(space partitioning)中的一种, 另一种常用的知名算法是
kdtree([fn::https://en.wikipedia.org/wiki/K-d_tree]). octree算法根据数据点的坐标
特征, 将数据点划分到大小不同的多个箱体中(Octant). 如果某个箱体中包含多个数据点,
再以递归的方式进行分解处理, 直至箱体的尺寸达到某个阈值. 这些箱体形成像树一样的层
级结构. 一旦octree构造完成, 搜索某个数据点的邻近点, 就可以循着树根, 搜索相关的子
箱体, 然后再计算与这些箱体中数据点的距离, 从而最终确定邻近与否. octree算法通过牺
牲一定的内存(octree数据结构), 极大地减小了后续需要几何距离计算的次数, 降低了计算
复杂度, 因而可以处理更大体系.

** 递归中止条件
- Octant的大小.
- bucket size: Octant所含数据点的多少.

** 构建octree
*** root octant
root octant包含所有数据点. 构建方式:
- 遍历数据点, 找到数据点在X轴, Y轴和Z轴这三个方向的展宽.
- 以最长的一端来设置octant的大小.
- 定义Octant的center.

*** 如何划分子箱体
- 计算新的center
- 计算新的extent
- 遍历octant中的点, 计算与center的相对坐标
- 对相对坐标的xyz进行分类, 8个象限中的点, 放入8个不同的octant.
- jbehley/octree的代码中使用morton code进行分类, 本质也是象限分法. 不过这能称为
  morton?

** 搜索球                                                           :ATTACH:
:PROPERTIES:
:Attachments: octree-overlap.svg
:ID:       44c04ba4-170e-48f2-bc2f-c23b167b0286
:END:
*** 大致思路
对搜索球与octant立方体间可能关系进行完全分类:
1. 立方体与搜索球有重叠区域
   1) 搜索球完全包含立方体
      - 将立方体中的所有点纳入需要进行距离计算的点集.
   2) 搜索球不完全包含立方体
      - 将立方体切分为更小的8个象限, 递归处理下去.
2. 立方体与搜索球无重叠区域: 忽略该立方体中的所有点.

*** 重叠与否的判断方法
1. 计算q在立方体坐标系下的相对坐标q', 将其镜像到第一象限(+++).
2. 如果q'的坐标xyz中任一分量大于e+r: 不重叠.
   : if (x > maxdist || y > maxdist || z > maxdist) return false;

3. 如果q'的坐标xyz中任一分量小于e: 重叠
   : int32_t num_less_extent = (x < o->extent) + (y < o->extent) + (z < o->extent);
   : // a. inside the surface region of the octant.
   : if (num_less_extent > 1) return true;

4. 如果q'的坐标xyz中任一分量都在e和e+r之间
   找到立方体中距离q'最近的端点m(e, e, e), 计算m至q'的距离, 判断是否小于r
   : // b. checking the corner region && edge region.
   : x = std::max(x - o->extent, 0.0f);
   : y = std::max(y - o->extent, 0.0f);
   : z = std::max(z - o->extent, 0.0f);
   : return (Distance::norm(x, y, z) < sqRadius);

问题:
- 对于corner case, 是否全部当做overlap来处理, 带来的损耗不一定很大? 这样可以避免
  计算一次distance. [2018-03-06 Tue] 经测试, 有微小改进, 几乎不可见.

- 原文中为了节省存储空间, octant只保留start_index和end_index. 这增加了代码的复杂
  度, 但对检索效率没有改进.

*** 包含与否的判断方法
找到立方体中距离搜索球中心最远的边界点(对角), 计算其距离. 或
将q'镜像到第一象限(+++), 求其与(---)对角点的距离.

#+name: fde176f5-dffa-48a9-ba79-f2519fca20cc
#+BEGIN_SRC cpp :tangle no
  float x = get<0>(query) - o->x;
  float y = get<1>(query) - o->y;
  float z = get<2>(query) - o->z;

  x = std::abs(x);
  y = std::abs(y);
  z = std::abs(z);
  // reminder: (x, y, z) - (-e, -e, -e) = (x, y, z) + (e, e, e)
  x += o->extent;
  y += o->extent;
  z += o->extent;

  return (Distance::norm(x, y, z) < sqRadius);
#+END_SRC

*** 特殊情况: 如果query point是octree中的一个数据点
这种情况下, 检索效率可以进一步提高.
- 所有的数据点分别属于大小不同的octant (leaf nodes).
- 根据query point的位置, 可以确定所归属的octant.
- 根据所归属的octant, 可以快速判断邻近的octants.
- 逆向搜索: 从枝节点向根节点搜索.

** References
- 原始文献: [[zotero://select/items/1_SEB7EZAD][Behley20152IICRAI]]
- CPP代码: [[https://github.com/jbehley/octree][jbehley/octree: Fast radius neighbor search with an Octree (ICRA 2015)]]

* cargo
#+BEGIN_SRC conf :tangle Cargo.toml
  [package]
  name = "octree"
  version = "0.0.4"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  timeit = "*"
  approx = "*"
#+END_SRC


* src
** lib.rs
:PROPERTIES:
:header-args: :tangle src/lib.rs
:END:
#+name: 7896c853-796e-4f97-b1d4-45546d4491db
#+begin_src rust
  #[macro_use] extern crate timeit;
  #[macro_use] extern crate approx;

  use std::error;
  use std::io::{self, BufReader};
  use std::io::prelude::*;
  use std::fs::File;

  mod types;
  pub mod octree;
  pub use octree::Octree;

  use types::{
      Point,
      Points,
  };

  pub type Result<T> = std::result::Result<T, Box<error::Error>>;
#+end_src

#+name: ddd95be2-3bf5-4478-a21b-ea0c8742f5cb
#+begin_src rust
  pub fn get_positions_from_xyz_stream(txt: &str) -> Result<Points> {
      let mut positions = Vec::new();

      for line in txt.lines() {
          let attrs: Vec<_> = line.split_whitespace().collect();
          let (symbol, position) = attrs.split_first().ok_or("encountering empty line")?;
          if position.len() != 3 {
              let msg = format!("informal xyz records: {}", line);
              Err(msg)?;
          }

          let p: Vec<f64> = position.iter().map(|x| x.parse().unwrap()).collect();
          positions.push([p[0], p[1], p[2]]);
      }

      Ok(positions)
  }

  // in a simple and dirty way
  pub fn get_positions_from_xyzfile(filename: &str) -> Result<Points> {
      let mut buffer = String::new();
      let f = File::open(filename)?;
      let mut f = BufReader::new(f);

      f.read_line(&mut buffer);
      f.read_line(&mut buffer);
      buffer.clear();

      f.read_to_string(&mut buffer)?;
      get_positions_from_xyz_stream(&buffer)
  }
#+end_src

** types.rs
:PROPERTIES:
:header-args: :tangle src/types.rs
:END:
*** docs :ATTACH:
:PROPERTIES:
:ID:       c8baaba3-1269-4d4a-adc8-e1f1e600c5e3
:Attachments: screenshot_2018-07-31_16-19-06.png
:END:

Octant struct:
- extent: 立方体半径
- center: 中心点坐标
- ipoints: 包含的数据点
- ranking: 在sibling节点中的排行
- children: 所有子节点

octree参数:
- bucket_size: 每个octant中容纳的最小点数.
- min_extent: 最小octant对应的半径
- root: 根节点索引

#+DOWNLOADED: @ 2018-07-31 16:19:06
#+caption: Octant和Search ball
#+name: fig:f37425e9
#+attr_org: :width 600
#+attr_odt: :width 14
[[file:data/c8/baaba3-1269-4d4a-adc8-e1f1e600c5e3/screenshot_2018-07-31_16-19-06.png]]

*** base
#+name: 172e83c4-c449-4a14-a72b-84c77c44743e
#+begin_src rust
  // set up aliases for convenience
  pub type Point = [f64; 3];
  pub type Points = Vec<Point>;
#+end_src

*** octant
#+name: d602663f-9f66-4e18-a538-e60b12985df3
#+begin_src rust
  #[derive(PartialEq, Eq, PartialOrd, Ord, Copy, Clone, Debug, Default, Hash)]
  pub struct OctantId (pub usize);

  #[derive(Clone, Debug, Default)]
  /// A specific node of octree
  pub struct Octant {
      /// tree related attributes
      /// for root octant, the parent is None
      pub parent: Option<OctantId>,
      pub children: Vec<OctantId>,

      /// The actual data which will be stored within the tree
      pub center: Point,
      /// The extent of octant (in radius)
      pub extent: f64,
      /// child points indicated with indices to point cloud
      pub ipoints: Vec<usize>,
      /// the ranking in sibling octant
      pub ranking: usize,
  }

  impl Octant {
      /// Construct an octant with defined extent (in radius)
      /// Panic if extent is negative
      pub fn new(extent: f64) -> Self {
          assert!(extent.is_sign_positive());
          Octant {
              extent: extent,
              ..Default::default()
          }
      }

      /// Construct root octant from a set of 3D points
      pub fn from_points(points: &[Point]) -> Self {
          // define the boundary in XYZ directions
          let mut p_min = points[0];
          let mut p_max = points[0];
          for p in points {
              for i in 0..3 {
                  if p[i] > p_max[i] {
                      p_max[i] = p[i];
                  } else if p[i] < p_min[i] {
                      p_min[i] = p[i];
                  }
              }
          }

          // Construct the root octant containg all points
          let mut distance = 0.0f64;
          for i in 0..3 {
              distance = distance.max(p_max[i] - p_min[i]);
          }
          let mut octant = Octant::new(0.5 * distance);

          octant.center = [(p_max[0] + p_min[0])/2., (p_max[1] + p_min[1])/2., (p_max[2] + p_min[2])/2.,];
          octant.ipoints = (0..points.len()).collect();

          octant
      }
  }
#+end_src

Octant和Octant之间的最小距离
#+name: 6405fadb-4d5f-4949-b689-d587cb65e506
#+begin_src rust
  impl Octant {
      /// test if two octants are neighboring
      pub fn neighboring(&self, other: &Octant) -> bool {
          let e = other.extent + self.extent;

          for i in 0..3 {
              let v = (other.center[i] - self.center[i]).abs() - e;
              if v > 0.001 {
                  return false;
              }
          }

          true
      }
  }

  #[test]
  fn test_octree_octant_neighboring() {
      let mut octant1 = Octant::new(45.051);
      octant1.center = [44.798034, 18.452375500000002, 121.71243299999999];
      let mut octant2 = Octant::new(22.525501);
      octant2.center = [67.32353549999999, -4.073125999999995, 144.2379345];
      assert!(octant1.neighboring(&octant2));

      let mut octant3 = Octant::new(22.525501);
      octant3.center = [22.272532500000004, -4.073125999999995, 144.2379345];
      assert!(octant2.neighboring(&octant3));

      let mut octant4 = Octant::new(2.8156876874999996);
      octant4.center = [13.825469437500008, -1.2574383124999953, 113.26536993749998];
      assert!(!octant3.neighboring(&octant4));
  }
#+end_src

*** query ball
#+name: 68bdbfaf-0d07-40c4-a77c-5c6b43ab440e
#+begin_src rust
  #[derive(Debug)]
  pub struct Query {
      pub center : Point,
      pub radius : f64,
  }

  /// Four possible relations of a query ball with an octant
  #[derive(Debug, PartialEq)]
  pub enum QORelation {
      /// the query ball has no common space with the octant
      Disjoint,
      /// the query ball is partially overlapping with the octant
      Overlaps,
      /// the query ball completely contains the octant
      Contains,
      /// the query ball is completely within the octant
      Within,
  }

  impl Query {
      pub fn new(r: f64) -> Self {
          assert!(r.is_sign_positive(), "radius has to be positive: {}", r);
          Query {
              center : [0.0; 3],
              radius : r,
          }
      }

      /// calculate the relation of query ball with octant
      pub fn relation(&self, octant: &Octant) -> QORelation {
          let extent = octant.extent;
          let radius = self.radius;

          let x = (self.center[0] - octant.center[0]).abs();
          let y = (self.center[1] - octant.center[1]).abs();
          let z = (self.center[2] - octant.center[2]).abs();

          // 1. cheap case: xyz > e+r
          let max_dist = extent + radius;
          if (x > max_dist || y > max_dist || z > max_dist) {
              return QORelation::Disjoint;
          }

          // 2. overlaps or not
          if (x < extent || y < extent || z < extent) {
              // expected to be common: e >= r
              // expected to be rare  : e < r
              if extent >= radius {
                  // 2.1 Within
                  // cheap case: xyz < e-r < e+r
                  let min_dist = extent - radius;
                  if (x <= min_dist && y <= min_dist && z <= min_dist) {
                      return QORelation::Within;
                  }
              } else {
                  if (x <= extent && y <= extent && z <= extent) {
                      // distance to the farthest corner point
                      let r_sqr = radius*radius;
                      let e = extent;
                      let d_sqr = (x+e)*(x+e) + (y+e)*(y+e) + (z+e)*(z+e);
                      // 2.2 Contains
                      if d_sqr <= r_sqr {
                          return QORelation::Contains;
                      }
                  }
              }
              // cheap case: e < x < e+r || e < y < e+r || z < e < e+r
              return QORelation::Overlaps;
          }

          // 3. corner case: Disjoint or Overlaps?
          // FIXME: can we just assume "Overlaps" to improve efficiency?
          // expensive case: e < xyz < e+r
          // distance to the nearest corner point
          let r_sqr = radius*radius;
          let e = extent;
          let d_sqr = (x-e)*(x-e) + (y-e)*(y-e) + (z-e)*(z-e);
          if d_sqr > r_sqr {
              return QORelation::Disjoint;
          }

          QORelation::Overlaps
      }
  }
#+end_src

*** tests
#+name: 81167b8a-bac9-4a8e-a6c9-56e48dcd6e79
#+begin_src rust
  #[test]
  fn test_octree_query_relations() {
      let octant = Octant::new(2.5);
      let mut query = Query::new(1.4);
      let r = query.relation(&octant);
      assert_eq!(r, QORelation::Within);

      query.radius = 4.4;         // 2.5*sqrt(3)
      let r = query.relation(&octant);
      assert_eq!(r, QORelation::Contains);

      let octant = Octant::new(2.5);
      let mut query = Query::new(0.4);
      query.center = [2.7, 2.7, 2.7];
      let r = query.relation(&octant);
      assert_eq!(r, QORelation::Overlaps);

      query.center = [2.7, -2.7, -2.7];
      let r = query.relation(&octant);
      assert_eq!(r, QORelation::Overlaps);

      query.center = [2.8, 2.8, 2.8];
      let r = query.relation(&octant);
      assert_eq!(r, QORelation::Disjoint);

      let query = Query {
          center: [31.079695, 10.200508, 146.169464],
          radius: 3.0
      };

      let mut octant = Octant::new(22.525501499999997);
      octant.center = [67.32353549999999, 40.977877, 144.2379345];
      let r = query.relation(&octant);
      assert_eq!(r, QORelation::Disjoint);
  }
#+end_src

#+name: 85a1bbdb-53b6-4dff-89e2-1ceba40b3c02
#+begin_src rust
  pub const XYZ_TXT: &str = " N                  0.49180679   -7.01280337   -3.37298245
   H                  1.49136679   -7.04246937   -3.37298245
   C                 -0.19514721   -5.73699137   -3.37298245
   H                 -0.81998021   -5.66018837   -4.26280545
   C                 -1.08177021   -5.59086937   -2.14084145
   C                  0.79533179   -4.58138037   -3.37298245
   H                 -0.46899721   -5.65651737   -1.24178645
   H                 -1.58492621   -4.62430837   -2.16719845
   H                 -1.82600521   -6.38719137   -2.13160945
   O                  2.03225779   -4.81286537   -3.37298245
   H                  0.43991988   -3.57213195   -3.37298245
   H                 -0.03366507   -7.86361434   -3.37298245 ";

  #[test]
  fn test_octree_init() {
      use super::*;

      let points = get_positions_from_xyz_stream(&XYZ_TXT).unwrap();
      let octant = Octant::from_points(&points);
      assert_relative_eq!(octant.center[0], 0.103126, epsilon=1e-4);
      assert_relative_eq!(octant.center[1], -5.717873145, epsilon=1e-4);
      assert_relative_eq!(octant.center[2], -2.75229595, epsilon=1e-4);
      assert_relative_eq!(octant.extent, 2.145741195, epsilon=1e-4);
  }
#+end_src

** octree.rs
:PROPERTIES:
:header-args: :tangle src/octree.rs
:END:
*** docs
问题:
- 一堆点构成的集合: R
- 一个特定的点, q
- 求R中所有与q邻近的点(cutoff=r)

References
- 定义: [[http://mathworld.wolfram.com/Octant.html][Octant -- from Wolfram MathWorld]]
- 文献: [[zotero://select/items/0_SEB7EZAD][@Behley20152IICRAI]]
- 代码: https://github.com/jbehley/octree/blob/master/Octree.hpp

*** base
#+name: 7711fb40-175f-4198-bff1-71c5fe1d7bd3
#+begin_src rust
  use std::collections::HashMap;
  use std::ops::{Index, IndexMut};

  use super::get_positions_from_xyz_stream;
  use super::get_positions_from_xyzfile;

  use types::*;

  #[derive(Clone, Debug)]
  pub struct Octree<'a> {
      /// adjustable parameter for min number points of octant while building octree
      pub bucket_size : usize,
      /// adjustable paramter for min octant extent while building octree
      pub min_extent  : f64,

      /// reference points in 3D space
      pub points  : &'a Points,
      /// private data storing all octants in octree
      pub octants : Vec<Octant>,
      /// root octant index to Octree.octans
      pub root    : OctantId,

      /// for quick access octant containing certain point
      mapping_octants : HashMap<usize, usize>,
  }

  impl<'a> Octree<'a> {
      /// Construct octree from points in 3D space
      pub fn new(points: &'a Points) -> Self {
          let octant = Octant::from_points(&points);
          let octants = vec![octant];
          let root = OctantId(0);

          Octree {
              points    : points,
              octants   : octants,
              root      : root,

              bucket_size : 8,
              min_extent  : 2.0,
              mapping_octants: HashMap::new(),
          }
      }

      pub fn root(&self) -> OctantId {
          OctantId(0)
      }

      /// Count octants in octree.
      pub fn count(&self) -> usize {
          self.octants.len()
      }

      /// Returns true if octree has no octant, false otherwise
      pub fn is_empty(&self) -> bool {
          self.octants.is_empty()
      }
  }

  impl<'a> Index<OctantId> for Octree<'a> {
      type Output = Octant;

      fn index(&self, node: OctantId) -> &Octant {
          &self.octants[node.0]
      }
  }

  impl<'a> IndexMut<OctantId> for Octree<'a> {
      fn index_mut(&mut self, node: OctantId) -> &mut Octant {
          &mut self.octants[node.0]
      }
  }
#+end_src

*** building
**** split node
将一个大的octant分割成8个小的.
#+name: 90433ce9-a63e-4f8e-b497-6cdd3bb88ca8
#+begin_src rust
  impl<'a> Octree<'a> {
      /// Add octant as orphan node in tree, return OctantId for further operation
      fn new_node(&mut self, octant: Octant) -> OctantId {
          let next_index = self.octants.len();
          self.octants.push(octant);

          OctantId(next_index)
      }

      /// Append a new child octant to parent node
      fn append_child(&mut self, parent_node: OctantId, mut octant: Octant) -> OctantId {
          octant.parent = Some(parent_node);
          octant.ranking = self[parent_node].children.len();
          let n = self.new_node(octant);

          // get parent octant, update children attributes
          let parent_octant = &mut self[parent_node];
          parent_octant.children.push(n);

          n
      }

      /// split parent octant into 8 child octants, and append them into octree
      fn split_octant(&mut self, parent_node: OctantId) {
          let child_octants = octree_create_child_octants(&self[parent_node], &self.points);

          for octant in child_octants {
              self.append_child(parent_node, octant);
          }
      }
  }

  /// octant: octree node data
  /// points: reference points in 3D space
  fn octree_create_child_octants(octant: &Octant, points: &Points) -> Vec<Octant> {
      let extent = octant.extent as f64 / 2f64;

      let mut octants = vec![];

      // initialize 8 child octants
      // 1. update center
      for i in 0..8 {
          let mut o = Octant::new(extent);
          let factors = get_octant_cell_factor(i);
          // j = 0, 1, 2 => x, y, z
          for j in 0..3 {
              o.center[j] += extent*factors[j] + octant.center[j]
          }
          octants.push(o);
      }

      // 2. update point indices
      if octant.ipoints.len() > 1 {
          let (x0, y0, z0) = (octant.center[0], octant.center[1], octant.center[2]);
          // 1. scan xyz
          for &i in octant.ipoints.iter() {
              let p = points[i];
              let (x, y, z) = (p[0] - x0, p[1] - y0, p[2] - z0);
              let index = get_octant_cell_index(x, y, z);
              octants[index].ipoints.push(i);
          }
      }

      octants
  }
#+end_src

#+name: 89da6ad4-0055-4246-84c7-9d19194c5405
#+begin_src rust
  // zyx: +++ => 0
  // zyx: ++- => 1
  // zyx: --- => 7
  // morton encode
  fn get_octant_cell_index(x: f64, y: f64, z: f64) -> usize {
      // create lookup table, which could be faster
      match (z.is_sign_positive(), y.is_sign_positive(), x.is_sign_positive()) {
          (true, true, true)    => 0,
          (true, true, false)   => 1,
          (true, false, true)   => 2,
          (true, false, false)  => 3,
          (false, true, true)   => 4,
          (false, true, false)  => 5,
          (false, false, true)  => 6,
          (false, false, false) => 7,
      }

      // another way: using bit shift
      // let bits = [z.is_sign_negative(), y.is_sign_negative(), x.is_sign_negative()];
      // bits.iter().fold(0, |acc, &b| acc*2 + b as usize)
  }

  #[test]
  fn test_octree_cell_index() {
      let index = get_octant_cell_index(1.0, 1.0, 1.0);
      assert_eq!(index, 0);

      let index = get_octant_cell_index(-1.0, -1.0, -1.0);
      assert_eq!(index, 7);

      let index = get_octant_cell_index(-1.0, 1.0, 1.0);
      assert_eq!(index, 1);

      let index = get_octant_cell_index(-1.0, -1.0, 1.0);
      assert_eq!(index, 3);
  }

  // useful for calculate center of child octant
  // morton decode
  fn get_octant_cell_factor(index: usize) -> Point {
      debug_assert!(index < 8 && index >= 0);
      [
          match (index & 0b001) == 0 {
              true => 1.0,
              false => -1.0,
          },
          match ((index & 0b010) >> 1) == 0 {
              true => 1.0,
              false => -1.0,
          },
          match ((index & 0b100) >> 2) == 0 {
              true => 1.0,
              false => -1.0,
          }
      ]
  }

  #[test]
  fn test_octree_factor() {
      let x = get_octant_cell_factor(0);
      assert_eq!(1.0, x[0]);
      assert_eq!(1.0, x[1]);
      assert_eq!(1.0, x[2]);

      let x = get_octant_cell_factor(7);
      assert_eq!(-1.0, x[0]);
      assert_eq!(-1.0, x[1]);
      assert_eq!(-1.0, x[2]);

      let x = get_octant_cell_factor(2);
      assert_eq!(1.0, x[0]);
      assert_eq!(-1.0, x[1]);
      assert_eq!(1.0, x[2]);
  }
#+end_src

**** build tree
#+name: 9db18239-7b01-48a3-aedc-7bcc082e7949
#+begin_src rust
  impl<'a> Octree<'a> {
      /// build octree by recursively creating all octants
      pub fn build(&mut self) {
          // calculate max allowed depth according min octant extent
          let max_extent = self.octants[0].extent as f64;
          let min_extent = self.min_extent as f64;
          let max_depth = ((max_extent/min_extent).ln()/2f64.ln()).floor() as usize;

          let root = self.root();
          let npoints = self.points.len();

          if npoints > self.bucket_size {
              let mut depth = 0;
              let mut need_split = vec![root];
              loop {
                  // 1. split into child octants
                  let mut remained = vec![];
                  for &parent_node in need_split.iter() {
                      self.split_octant(parent_node);
                      for &child_node in &self[parent_node].children {
                          let octant = &self[child_node];
                          let n = octant.ipoints.len();
                          if n > self.bucket_size {
                              remained.push(child_node);
                          }
                      }
                  }

                  // 2. drill down to process child octants
                  need_split.clear();
                  need_split.extend(remained);

                  // 3. loop control
                  if need_split.is_empty() {
                      println!("octree built after {:?} cycles.", depth);
                      break;
                  }
                  depth += 1;
                  if depth >= max_depth {
                      eprintln!("octree build: max allowed depth {} reached.", depth);
                      break;
                  }
              }
          }

          // cache octants
          // create mapping of point => octant
          for (i, ref octant) in self.octants.iter().enumerate() {
              for &j in octant.ipoints.iter() {
                  self.mapping_octants.insert(j, i);
              }
          }
      }
  }
#+end_src

**** tests                                                        :ATTACH:
:PROPERTIES:
:Attachments: test.com
:ID:       5c01b428-563a-4c9b-9e23-0256c5d752e3
:END:
#+name: 9317478e-996f-4323-9310-e1ca841b8832
#+begin_src rust
  #[test]
  fn test_octree_struct() {
      let points = get_positions_from_xyz_stream(&XYZ_TXT).unwrap();
      let mut octree = Octree::new(&points);

      // test octree
      let root = octree.root();
      let octant = Octant::new(1.2);
      let child1 = octree.append_child(root, octant);
      assert_eq!(&octree[child1].parent, &Some(root));

      let octant = Octant::new(1.2);
      let child2 = octree.append_child(root, octant);
      let octant = Octant::new(1.3);
      let child3 = octree.append_child(child1, octant);

      let root_octant = &octree[root];
      assert!(root_octant.children.contains(&child1));
      assert!(root_octant.children.contains(&child2));
      assert_eq!(octree.count(), 4);

      let octant1 = &octree[child1];
      assert_eq!(octant1.extent, 1.2);
      assert!(octant1.children.contains(&child3));
  }
#+end_src

#+name: ea2c2276-5aaa-406e-9d5f-11a258f38cc0
#+begin_src rust
  #[test]
  fn test_octree_split_children() {
      let points = get_positions_from_xyz_stream(&XYZ_TXT).unwrap();
      let mut octree = Octree::new(&points);
      let root = octree.root();
      octree.split_octant(root);

      // reborrow as immutable
      let octree = octree;
      // root octant
      let octant = &octree[root];
      println!("{:?}", octree);

      let children = &octant.children;
      let child = &octree[children[0]];
      let x = child.center[0] - octant.center[0];
      let y = child.center[1] - octant.center[1];
      let z = child.center[2] - octant.center[2];
      assert_relative_eq!(x, y, epsilon=1e-4);
      assert_relative_eq!(x, z, epsilon=1e-4);

      assert_eq!(octant.extent, child.extent * 2.0);

      let child = &octree[children[1]];
      let x = child.center[0] - octant.center[0];
      let y = child.center[1] - octant.center[1];
      let z = child.center[2] - octant.center[2];
      assert_relative_eq!(x, child.extent * -1., epsilon=1e-4);
      assert_relative_eq!(y, child.extent * 1., epsilon=1e-4);
      assert_relative_eq!(z, child.extent * 1., epsilon=1e-4);

      let child7 = &octree[children[7]];
      println!("{:?}", octant);
      println!("{:?}", child7);

      assert!(child7.ipoints.contains(&2));
      assert_eq!(child7.parent, Some(root));
  }
#+end_src
*** nearby search
**** docs
1. octant is overlapped by query ball
   1) query ball contains octant
      - all points need to compute distances
   2) query ball partially overlapped with octant
      - process child octants
2. no overlapping between octant and query ball
   : ignore this octant completely

**** src
#+name: bbcfff81-6ec6-4e9e-a787-8641691e6435
#+begin_src rust
  impl<'a> Octree<'a> {
      /// Search nearby points within radius of center.
      /// Return
      /// ------
      /// indices of nearby points and distances
      pub fn search(&self, p: Point, radius: f64) -> Vec<(usize, f64)> {

          let mut query = Query::new(radius);
          query.center = p;

          let mut pts_maybe: Vec<usize> = vec![];

          // step 1: record all nearby points by octree search
          let mut nodes_to_visit = vec![self.root()];
          loop {
              let mut todo = vec![];
              for &parent in nodes_to_visit.iter() {
                  let octant = &self[parent];
                  match query.relation(&octant) {
                      QORelation::Overlaps | QORelation::Within => {
                          // println!("overlaps");
                          if octant.children.is_empty() {
                              // is a leaf node: save points
                              pts_maybe.extend(octant.ipoints.iter());
                          } else {
                              // not a leaf node: go down to follow children
                              todo.extend(octant.children.iter());
                          }
                      },

                      QORelation::Contains => {
                          pts_maybe.extend(octant.ipoints.iter());
                      },

                      QORelation::Disjoint => {
                          ;
                      },
                  };
              }

              if todo.is_empty() {
                  break;
              }

              nodes_to_visit.clear();
              nodes_to_visit.extend(todo.iter());
          }

          // step 2: linear search
          let (qx, qy, qz) = (query.center[0], query.center[1], query.center[2]);
          let radius = query.radius as f64;
          let rsqr = radius * radius;

          let mut neighbors = vec![];
          for &i in pts_maybe.iter() {
              let (px, py, pz) = (self.points[i][0], self.points[i][1], self.points[i][2]);
              let dsqr = (px-qx)*(px-qx) + (py-qy)*(py-qy) + (pz-qz)*(pz-qz);
              if dsqr < rsqr {
                  neighbors.push((i, dsqr.sqrt()));
              }
          }

          neighbors
      }
  }
#+end_src

*** neighbors
**** docs                                                         :ATTACH:
:PROPERTIES:
:Attachments: octree-levels.svg
:ID:       88d007ca-0efa-4e4d-9c7f-b4c05d2b665c
:END:
假设数据点在points数组中, 搜索过程可以进一步简化?

1. 找到数据点所在的octant
2. 建立以数据点为中心的query ball
3. 测试query ball是否within octant
   1) 如果是, 结束.
   2) 如果否, 继续
4. 找到octant的siblings
   + 计算query ball与brother octant的关系
     - 如果contains, 收集brother octant中的points
     - 如果overlaps, 进入该brother octant, 找其child octants(与search类似)
     - 如果disjoint, 略过.
     - 如果是within: 这种情况不可能.
5. 向树根走, 找到parent octant
6. 测试: query ball within parent octant
   1) 如果是, 结束.
   2) 如果否, 继续.
7. 找到parent octant的其它sibling octants. 重复之前的过程.
8. 如果到达最顶层, 停止向上递归.

all fixed radius neighbor search, i.e. it can find all point pairs in a set that
are within a certain radius of each other.

**** src
#+name: 0a1e3f93-a0f2-46a0-a98b-a67d458e14ac
#+begin_src rust
  impl<'a> Octree<'a> {
      /// Find neighboring points
      ///
      /// Parameters
      /// ----------
      /// radius: the query ball radius
      ///
      /// Return
      /// ------
      /// indices of neighboring points in pairs
      ///
      pub fn neighbors(&self, radius: f64) -> Vec<(usize, usize, f64)>{
          let mut pairs = vec![];

          for (i, &p) in self.points.iter().enumerate() {
              let neighbors = self.search(p, radius);
              for &(j, d) in neighbors.iter() {
                  if j != i {
                      pairs.push((i, j, d));
                  }
              }
          }

          pairs
      }
  }
#+end_src

*** playground
**** neighbors
#+name: 7e3b12c9-d3f8-4bfc-8ed0-46e2644660d3
#+begin_src rust :tangle no
  use std::collections::HashSet;
  use itertools::Itertools;

  impl<'a> Octree<'a> {
      /// Find neighboring points
      ///
      /// Parameters
      /// ----------
      /// radius: the searching radius
      ///
      /// Return
      /// ------
      /// indices of neighboring points in pairs
      ///
      pub fn neighbors(&self, radius: f64) -> Vec<(usize, usize)>{
          let radius2 = radius*radius;
          let mut pairs = vec![];
          let mut count = 0;

          let mut leaves = vec![];
          for octant in self.octants.iter() {
              if octant.children.is_empty() {
                  leaves.push(octant);
                  // println!("octant ranking = {:?}", octant.ranking);
                  for (i, &pi) in octant.ipoints.iter().enumerate() {
                      for (j, &pj) in octant.ipoints.iter().enumerate().skip(i+1) {
                          let pi = self.points[pi];
                          let pj = self.points[pj];
                          let px = pj[0] - pi[0];
                          let py = pj[1] - pi[1];
                          let pz = pj[2] - pi[2];
                          let d2 = px*px + py*py + pz*pz;
                          if d2 < radius2 {
                              pairs.push((i, j));
                          }
                      }
                  }
              }
          }
          println!("non-empty octants = {:?}", count);

          pairs
      }
  }
#+end_src

根据tree中octant的相对关系, 建立graph
#+name: b9ec4831-6818-4f72-b237-58dae424957a
#+begin_src rust :tangle no
  use std::collections::HashSet;
  use petgraph::graphmap::UnGraphMap;
  use itertools::Itertools;

  impl<'a> Octree<'a> {
      /// return a Graph instance in petgraph crate
      fn get_graph(&self, min_extent: f64) -> UnGraphMap<usize, usize> {
          let mut graph = UnGraphMap::new();
          let mut leaves = vec![];
          for (i, octant) in self.octants.iter().enumerate() {
              if octant.children.is_empty() {
                  leaves.push(i);
              }
          }

          for pair in leaves.iter().combinations(2) {
              let n1 = pair[0];
              let n2 = pair[1];
              let octant1 = &self.octants[*n1];
              let octant2 = &self.octants[*n2];
              if octant1.neighboring(&octant2) {
                  graph.add_edge(*n1, *n2, 1);
              }
          }

          graph
      }
  }
#+end_src

**** octant node
使用Vec<u8>对octant进行唯一编码, 实现parent, siblings, children等功能.

#+name: f540ab1a-4909-414a-83b6-e38f08c68923
#+begin_src rust :tangle no
  #[derive(Clone, Debug, Hash)]
  struct OctantNode {
      /// Unique key for Octant by a list of integer number
      key: Vec<u8>,

      /// number of children
      family_size: u8,
  }

  impl OctantNode {
      fn new(key: Vec<u8>) -> Self {
          OctantNode {
              key: key,
              family_size: 8,
          }
      }

      /// Figure out the key point to parent node
      fn parent(&self) -> Option<Self> {
          println!("{:?}", self.key);
          None
      }

      /// Create a new node with key pointing to a child node with index
      fn new_child(&self, index: u8) -> Self {
          let mut new_key = self.key.clone();
          new_key.push(index);

          OctantNode::new(new_key)
      }

      /// Return sibling nodes excluding current node
      fn siblings(&self) -> Vec<Self> {
          let brothers = vec![];

          assert!(! self.key.is_empty(), "OctantNode key cannot be empty.");

          let &v = self.key.last().unwrap();
          for i in 0..self.family_size {
              if i != v {
                  let mut new_key = self.key.clone();
                  let k = new_key.last_mut().unwrap();
                  ,*k = i;
                  brothers.push(OctantNode::new(new_key));
              }
          }

          brothers
      }
  }

  #[test]
  fn test_octree_octant_node() {
      let mut node = OctantNode::new(vec![1, 0, 3]);

      let x = node.parent();
      println!("{:?}", x);
      let x = node.new_child(3);
      println!("{:?}", x);
  }
#+end_src

**** linear octree
基于octant唯一编码的hashmap

#+name: 6638ce82-a315-4f81-b92f-c235068cd5e3
#+begin_src rust :tangle no
  #[derive(Clone, Debug)]
  pub struct Octree2<'a> {
      /// adjustable parameter for min number points of octant while building octree
      pub bucket_size : usize,
      /// adjustable paramter for min octant extent while building octree
      pub min_extent  : f64,

      /// reference points in 3D space
      pub points  : &'a Points,
      /// hashmap storing created octants
      octants : HashMap<Vec<u8>, Octant>,
      /// for quick access octant containing certain point
      mapping_octants : HashMap<usize, usize>,
  }

  impl<'a> Octree2<'a> {
      /// initialize octree from points in 3D space
      pub fn new(points: &'a Points) -> Self {
          let octant = Octant::from_points(&points);
          let mut octants = HashMap::new();
          octants.insert(vec![0], octant);

          Octree2 {
              points    : points,
              octants   : octants,

              bucket_size : 8,
              min_extent  : 2.0,
              mapping_octants: HashMap::new(),
          }
      }

      /// Count octants in octree.
      pub fn count(&self) -> usize {
          self.octants.len()
      }

      /// Returns true if octree has no octant, false otherwise
      pub fn is_empty(&self) -> bool {
          self.octants.is_empty()
      }
  }
#+end_src


** examples
*** data/pdb4rhv.xyz :ATTACH:
:PROPERTIES:
:ATTACH_DIR: examples/data/
:Attachments: pdb4rhv.xyz result.txt
:END:

*** demo.rs
:PROPERTIES:
:header-args: :tangle examples/demo.rs
:END:
#+name: b9a6ab02-bfca-4340-8aec-16fe3c042a9d
#+begin_src rust
  #[macro_use]
  extern crate timeit;
  extern crate octree;

  fn main() {
      // external xyz file
      use octree::*;

      let stream = include_str!("data/pdb4rhv.xyz");
      let points = get_positions_from_xyz_stream(stream).unwrap();

      let mut tree = Octree::new(&points);
      tree.bucket_size = 8*8;
      tree.build();

      let stream = include_str!("data/result.txt");
      for (line, &p) in stream.lines().zip(points.iter()) {
          let mut expected: Vec<_> = line.split_whitespace().map(|x| x.parse().unwrap()).collect();
          let mut x = tree.search(p, 3.0);
          let mut y: Vec<_> = x.iter().map(|v| v.0).collect();
          y.sort();
          assert_eq!(y, expected);
      }

      timeit!({
          for &q in tree.points.iter() {
              tree.search(q, 3.0);
          }
      });

      timeit!({
          tree.neighbors(3.0);
      });
  }
#+end_src

** tests
*** data/ :ATTACH:
:PROPERTIES:
:ATTACH_DIR: tests/data/
:Attachments: pdb4rhv.xyz result.txt
:END:

*** test_octree.rs
:PROPERTIES:
:header-args: :tangle tests/octree.rs
:ID:       38431531-4955-4c81-9570-86c776602192
:END:

#+name: 2f321e55-2849-4b73-aaf9-cd3271843de0
#+begin_src rust
  #[macro_use] extern crate octree;

  #[test]
  fn test_octree() {
      use octree::*;

      let stream = include_str!("data/pdb4rhv.xyz");
      let points = get_positions_from_xyz_stream(stream).unwrap();

      let mut tree = Octree::new(&points);
      tree.bucket_size = 8*8;
      tree.build();

      let stream = include_str!("data/result.txt");
      for (line, &p) in stream.lines().zip(points.iter()) {
          let mut expected: Vec<_> = line.split_whitespace().map(|x| x.parse().unwrap()).collect();
          let mut x = tree.search(p, 3.0);
          let mut y: Vec<_> = x.iter().map(|v| v.0).collect();
          y.sort();
          assert_eq!(y, expected);
      }
  }
#+end_src


* README [[file:README.org][edit]]

* Local variables
# Emacs:
# Local Variables:
# mode: org
# end:
